---
output:
  pdf_document: default
  html_document: default
---
# Notes for Chapter 9

## Welcome to the `tidyverse`

`tidyverse` is a bundle of many inter-related packages. They share the same philosophy, as well as a common data structure. Learning one of the packages in the `tidyverse` should make it simpler to learn the next one, as they all work well with each other. We are going to explore the manipulation of data sets and their visualization.

To load the **core** packages of `tidyverse` simply load the library:
```{r, message=FALSE}
library(tidyverse)
```

For a list of available packages
```{r, eval=FALSE}
tidyverse_packages()
```


You can update all the packages by calling
```{r, eval=FALSE}
tidyverse_update()
```

## Loading data

There are a number of specialized functions to read character-delimited and fixed-width tables:
```{r}
ants <- read_csv("../data/Mersch2013/behavior.csv") 
```
use `read_csv2()` for `;`-delimited, `read_tsv()` for `Tab`-delimited, `read_delim()` for general character-delimited (set `delim = ` to set the delimiter), and `read_fwf()` for fixed-width tables.

All these functions: i) try to guess the type of content of each column, and report their choice for you to check; ii) do not convert strings into damn factors; iii) are much faster than the corresponding base-R functions; iv) show you a progress bar for large data sets.

Data is returned as a `tibble`, a modern version of `data.frame`. Several functions can be used to take a look at the data:

```{r, eval=FALSE}
ants # shows the default visualization of tibbles
head(ants) # first few rows
head(ants, 3)
tail(ants, 3) # last three rows
glimpse(ants) # structure of the data 
View(ants) # open a spreadheet visualization
```

## Subsetting the data

We can subset the rows (observations) or columns (fields). To select rows matching a given condition, use `filter`:

```{r, eval=FALSE}
filter(ants, colony == 4)
# multiple filters
filter(ants, colony == 4, age > 30)
filter(ants, colony == 4, age > 100, group_period1 == "F")
# using logical operators
filter(ants, colony == 4, age < 30 | age > 100)
# using %in% 
filter(ants, colony == 4, group_period1 %in% c("F", "Q"))
```

Several functions return a subset of the data:

```{r, eval=FALSE}
# 1% of the data at random
sample_frac(ants, 0.01)
# 5 random rows
sample_n(ants, 5)
# rows 5 to 10
slice(ants, 5:10)
# top 5 rows once ordered by body_size
top_n(ants, 5, body_size)
# bottom 5 rows once ordered by body_size
top_n(ants, -5, body_size)
```

To choose particular columns, use `select`:

```{r, eval=FALSE}
select(ants, colony, age)
# choose all columns whose name contains "group"
select(ants, colony, contains("group"))
# starting with "visit"
select(ants, colony, starts_with("visit")) # also ends_with
# select columns with the same base name followed by a number
select(ants, num_range("group_period", 1:2))
# select columns using regular expressions
select(ants, matches("*.\\d")) 
# use - to exclude columns
select(ants, -colony, -age)
```

To take only rows with distinct values, use `distinct`:

```{r, eval=FALSE}
distinct(select(ants, colony))
distinct(select(ants, colony, group_period1))
```

## Pipes

Writing nested commands detracts from readability, and makes it difficult to change and extend the analysis (e.g., matching parentheses). `tidyverse` is based on **pipes**, like the ones we've seen for UNIX. 

```{r}
ants %>% select(colony) %>% distinct()
```

to type `%>%` press `Ctrl+Shift+M`.

## Ordering the data
You can sort according to column(s) content with `arrange`:

```{r}
ants %>% select(colony) %>% distinct() %>% arrange(colony)
ants %>% select(colony) %>% distinct() %>% arrange(desc(colony))
```

## Modifying columns

To rename a column, use `rename`

```{r}
ants %>% select(colony, age, body_size) %>% rename(bsize = body_size)
```

To add a new column, whose content is a function of the other columns, use `mutate`

```{r}
ants %>% select(colony, age) %>% mutate(age_yrs = age / 365.25)
```

To drop the columns used for the calculation, use `transmute`

```{r}
ants %>% select(colony, age) %>% transmute(age_yrs = age / 365.25)
```

## Counting and computing statistics

To count the number of rows, use `tally`

```{r}
ants %>% tally()
```

To calculate simple statistical summaries, use `summarise`

```{r}
ants %>% summarise(avg_bs = mean(body_size), 
                   sd_bs = sd(body_size), 
                   cor_age_bs = cor(age, body_size))
```

## Grouping

The real strength of this approach is that you can group the rows according to some criterion, and perform `mutate`, `tally` or `summarise` for each group separately:

```{r}
ants %>% group_by(colony, group_period1) %>% tally()

ants %>% group_by(age) %>% 
  summarise(avg_bs = mean(body_size))

ants %>% group_by(colony, group_period1) %>% 
  summarise(number = n(), avg_bs = mean(body_size)) %>% 
  arrange(colony, avg_bs)

ants %>% group_by(group_period1) %>% summarise(max_bs = max(body_size))
```

## INTERMEZZO
- calculate average body size per colony
- queens can live up to 26 years: how old were the queens in this experiment?
- how old is the oldest forager? (use `group_period1 == "F"`)
- find the oldest individual per role (`F`, `C`, `N`, `Q`) --- there's an error in the data! One ant lived for 107 years...

## Plotting
Idea behind `ggplot2`: describe graphs like well-formed sentences (a grammar of graphics).

- Data to plot (the subject) `ggplot(data = ants)`
- Aesthetic mapping: what is what? `ggplot(data = ants) + aes(x = age, y = body_size)`
- Geometry `ggplot(data = ants) + aes(x = age, y = body_size) + geom_point()`

```{r, eval = FALSE}
ggplot(data = ants %>% filter(age < 2000)) + 
  aes(x = age, y = body_size) + geom_point()
# add a smoother
ggplot(data = ants %>% filter(age < 2000)) + 
  aes(x = age, y = body_size) + geom_point() +
  geom_smooth()
# exclude queens
ggplot(data = ants %>% 
         filter(age < 2000, group_period1 != "Q")) +
  aes(x = age, y = body_size) + geom_point() +
  geom_smooth()
# by role
ggplot(data = ants %>% 
         filter(age < 2000, group_period1 != "Q")) +
  aes(x = age, y = body_size, colour = group_period1) +
  geom_point() + geom_smooth()
```

## One variable
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(age < 2000, group_period1 != "Q")) 
pl + geom_histogram(aes(body_size), bins = 40) # histogram
pl + geom_density(aes(body_size)) # density plot
pl + geom_bar(aes(group_period1)) # barplot (discrete)
```

## One variable, discrete x axis 
```{r, eval = FALSE}
pl + geom_boxplot(aes(x = group_period1, y = age)) # boxplot
pl + geom_violin(aes(x = group_period1, y = age)) # violin plot
```

## Two continuous variables
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(group_period1 == "F"), 
       aes(x = body_size, y = foraging_events))
pl + geom_point()
pl + geom_point() + geom_smooth()
pl + geom_point() + geom_smooth(method = "lm") # linear model
pl + geom_point() + geom_smooth(se = FALSE) # no error ribbon
pl + geom_point() + geom_line()
```

## Scales
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(age < 2000), 
             aes(x = age, y = body_size, 
                 colour = group_period1)) + 
  geom_point()
pl + scale_colour_brewer(palette = "Set1")
pl + scale_colour_manual(values = c("yellow", 
                                    "red", 
                                    "green", 
                                    "blue"))
pl + scale_x_log10("age in days") + 
  scale_y_sqrt("body size (in pixels, 0.06 mm)")
pl <- ggplot(data = ants %>% 
               filter(age < 2000), 
             aes(x = age, y = body_size, 
                 colour = log(age))) + 
  geom_point() + 
  scale_x_log10()
pl + scale_color_gradient2(low = "black", 
                           mid = "green", high = "red")
pl + aes(shape = group_period1, 
         size = body_size)
```

## Facets
```{r, eval = FALSE}
pl <- ggplot(data = ants, 
             aes(x = body_size, colour = group_period1, fill = group_period1)) +
  geom_histogram(alpha = 0.1, position = position_dodge())
pl + facet_grid(~colony)
pl + facet_grid(colony~.)
pl + facet_grid(colony~group_period1)

```

## Themes
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(age < 2000), 
             aes(x = age, y = body_size, colour = group_period1)) + 
  geom_point()
pl + theme_bw()
pl + theme_dark()
pl + theme_minimal()
pl + theme_bw() + theme(legend.position = "bottom")
pl + theme_bw() + theme(legend.position = "none") + 
  xlab("description x axis") + ggtitle("my main title")
```

## Legends
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(age < 2000), 
             aes(x = age, y = body_size, 
                 colour = group_period1,
                 shape = group_period1,
                 size = body_size)) + 
  geom_point() + 
  facet_wrap(~group_period1, scales = "free")
show(pl)
pl + guides(colour = "none")
pl + scale_size_continuous("my legend", 
                           breaks = c(100, 200, 300))
pl + scale_shape_discrete("my shapes", solid = FALSE)
```

## Setting a value
```{r, eval = FALSE}
ggplot(data = ants, aes(x = factor(colony))) + 
  geom_bar(colour = "red", fill = "darkblue")
ggplot(data = ants, aes(x = group_period1, 
                        y = body_size, 
                        colour = group_period1)) + 
  geom_jitter(alpha = 0.5)
```

## Stats
```{r, eval = FALSE}
ggplot(data = ants %>% filter(age < 2000), 
       aes(x = age, y = body_size)) + stat_bin2d()
ggplot(data = ants %>% filter(age < 2000), 
       aes(x = age, y = body_size)) + stat_density2d()
ggplot(data = ants %>% filter(age < 2000), 
       aes(x = age, y = body_size)) + 
  geom_point() + stat_ellipse(level = 0.75, colour = "red")
ggplot(data = ants %>% filter(age < 2000), 
       aes(x = age)) + stat_ecdf()
pl <- ggplot(data = ants %>% filter(age < 2000), 
             aes(x = age, y = body_size)) + 
  geom_point()
pl + stat_summary(fun.y = "median", 
                  geom = "point", 
                  colour = "red", shape = 3)
ggplot(data = ants, 
       aes(x = group_period1, 
           y = body_size, 
           colour = group_period1)) + 
  geom_jitter(alpha = 0.5) + 
  stat_summary(fun.data = "mean_cl_normal", colour = "black")

```

## Adding multiple geometries
```{r, eval = FALSE}
pl <- ggplot(data = ants %>% filter(age < 2000), 
             aes(x = age, y = body_size)) + geom_point()
pl + geom_abline(intercept = 0, 
                 slope = 2, linetype = 2, 
                 colour = "red") + 
  geom_vline(xintercept = 500, linetype = 3)
```

## Saving
```{r, eval = FALSE}
ggsave(pl, file = "test.png", width = 5, height = 7)
```

## INTERMEZZO
- produce a boxplot showing the distribution of foraging events by `group_period1`. Set the scale for the `y` axis in square root.
- plot an histogram of foraging events by colony and `group_period1`.

## Tidy data
The concept of tidy data is simple: each variable has its own column; each observation has its own row. As the name implies `tidyverse` is meant to manipulate tidy data. There are many functions to help you wrestle with your data to make it into tidy form.

### Gathering 
```{r, eval = FALSE}
visits <- ants %>% group_by(group_period1, colony) %>% 
  summarise(rubbish = mean(visits_rubbishpile), 
            brood = mean(visits_brood), 
            entrance = mean(visits_entrance)) 
visits <- visits %>% gather(location, average_visits, 3:5)
ggplot(data = visits, aes(x = group_period1, 
                          y = location, 
                          fill = group_period1, 
                          alpha = sqrt(average_visits))) + 
  geom_tile() + facet_wrap(~colony)
```

### Spreading 
```{r, eval = FALSE}
foraging_by_colony <- ants %>% 
  group_by(colony, group_period1) %>% 
  summarise(avg_foraging = mean(foraging_events))
foraging_by_colony <- foraging_by_colony %>% 
  spread(group_period1, avg_foraging)
```

### Example: moving between groups
Some ants change of status between `group_period1` and `group_period2`. We are going to investigate how frequent this is.
```{r, eval = FALSE}
roles <- ants %>% select(group_period1, group_period2) %>% 
  rename(p1 = group_period1, p2 = group_period2)
# add a counter
roles <- roles %>% 
  mutate(count = 1) %>% 
  group_by(p1, p2) %>% 
  summarise(transitions = sum(count))
# remove nas
roles <- roles %>% filter(!is.na(p2))
# we want to have probabilities: sum by p1
roles <- roles %>% group_by(p1) %>% 
  mutate(tottrans = sum(transitions)) %>% 
  mutate(prob = transitions / tottrans)
ggplot(data = roles, aes(x = p1, y = p2, fill = prob)) + 
  geom_tile()
# table for paper
roles %>% select(p1, p2, prob) %>% spread(p2, prob, fill = 0)
```

## Joining data
Suppose we have two dataframe, sharing some of the columns, but not others:

```{r}
colony_numbers <- ants %>% 
  group_by(colony, group_period1) %>% 
  tally()
colony_large <- ants %>% 
  group_by(colony) %>% 
  tally() %>% rename(tot = n) %>% 
  filter(tot > 150)
```

We can combine them by using 
```{r}
inner_join(colony_numbers, colony_large) # intersection
left_join(colony_numbers, colony_large) # in A, possibly in B
right_join(colony_numbers, colony_large) # in B, possibly in A
full_join(colony_numbers, colony_large) # in A or B
anti_join(colony_numbers, colony_large) # not in A or not in B
```

### PEARSON AND WARNER 2016
Pearson and Warner collected eggs from caged brown anoles (*Anolis sagrei*), and incubated them at conditions mimicking seasonal variability (April vs July) and microhabitats (open vs shade). For the hatched organisms, they (repeatedly) measured their size as well as their speed when chased by a paintbrush (!). 

- Plot the probability of hatching for eggs in the four different conditions

<!--% a %>% select(Habitat, Month,`Egg ID`,`Egg Survival`) %>% distinct() %>% group_by(Habitat, Month, `Egg Survival`) %>% tally() %>% spread(`Egg Survival`, n) %>% mutate(prob = Y / (Y + N)) -->

- Plot the average speed over 1 m (with standard errors)  for the four conditions. Use organisms at 1 week of age.

- Plot speed against the `Snout-Vent Length`.


